# 第一章

## 1.3 事务

### 定义

1. 事务是一组SQL查询，或者说一个独立的工作单元。（原子性）

2. 事务内的语句，要么全部执行成功，要么全部执行失败。（原子性）



### 应用

银行应用是解释事务必要性的一个经典例子。

![image-20190807100049762](/Users/pengyuyan/Documents/Android-Learning-Material/SQL/高性能SQL/images/image-20190807100049762.png)

**Note**:COMMIT用于提交事务，ROLLBACK用于回滚。



### ACID特性

一个运行良好的事务处理系统，必须具备ACID特性。

| 字母 | 全称        | 具体含义                                                     |
| ---- | ----------- | ------------------------------------------------------------ |
| A    | Atomicity   | 其含义如定义中所示                                           |
| C    | Consistency | 数据库总是从一个一致性的状态转换到另一个一致性的状态，比如，如果银行例子中的第3、4语句之间发生了奔溃，支票账户也不会损失200元，因为事务最终没有提交 |
| I    | Isolation   | 通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的，即在最后的5之前，3、4对支票账户的修改对其他事务是不可见的 |
| D    | Durability  | 一旦事务提交，则其所做的修改就会永久保存在数据库中           |



事务处理过程中额外的安全性，通常会需要更强的CPU能力、更大的内存和更多的磁盘空间。但其实如果一个存储引擎没有提供这样的事务处理过程，用户也可以通过锁表来提供一定程度的保护。



### 1.3.1 隔离级别

| 隔离级别        | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| --------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITED | Yes        | Yes              | Yes        | No     |
| READ COMMITED   | No         | Yes              | Yes        | No     |
| REPEATABLE READ | No         | No               | Yes        | No     |
| SERIALIZABLE    | No         | No               | No         | Yes    |

（这个没有弄得太明白）其中，REPEATABLE READ是MySQL的默认事务隔离级别。



### 1.3.2 死锁

#### 定义

两个或多个事务在统一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。



#### 例子

![image-20190807111014446](/Users/pengyuyan/Documents/Android-Learning-Material/SQL/高性能SQL/images/image-20190807111014446.png)



数据库中实现了一些死锁检索和死锁超时机制来应对死锁的问题。比如，

1. 检测到死锁的循环依赖，并立即返回一个错误；
2. 当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好；
3. InnoDB目前处理死锁的方式是，将拥有最少行级排他锁的事务进行回滚；



需要注意的是锁的行为和顺序是与存储引擎相关的。也就说，以同样的顺序执行语句，有的存储引擎会产生死锁，有的则不会。死锁产生的原因是双重的，既有数据本身的冲突原因，而也可能是因为存储引擎引起的。



### 1.3.3 事务日志

现在我们来了解一下事务日志是如何来帮助提高事务的效率的？

![image-20190807113353106](/Users/pengyuyan/Documents/Android-Learning-Material/SQL/高性能SQL/images/image-20190807113353106.png)

修改表数据的流程，

1. 修改内存中的表数据；
2. 追加事务日志（顺序I/O而非随机I/O）；
3. 内存汇总被修改的数据慢慢刷回到磁盘；

我们将这种做法称做“预写式日志”，修改数据需要写两次磁盘。



### 1.3.4 MySQL 中的事务

MySQL 中提供了两种事务引擎，InnoDB和NDB Cluster，此外还有一些第三方存储引擎。



#### 自动提交



### 1.5.6 转换表的引擎

| 转换引擎的方法 | 实际操作                                                     | 注意                                                 |
| -------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| alter table    | alter table mytable engine = InnoDB;<br />实际上将原表复制到了新表中，会消耗系统的I/O能力，原表会加读锁，因此该过程会非常慢。 | 若转换表引擎，会失去原有引擎的所有特性。             |
| 导出与导入     | mysql导出表至文件中，create table （新引擎），并将表导入     | create table时注意修改表明，同时不要误操作drop table |
| 创建与查询     | 先创建一个新的存储引擎的表，然后用 insert…select 导入数据<br />![image-20190816115656474](/Users/pengyuyan/Documents/Android-Learning-Material/SQL/高性能SQL/images/image-20190816115656474.png) | 数据量不大的时候这样操作比较好。                     |



## 1.6 MySQL TimeLine

| 年份     | 版本  | 特性                                                         |
| -------- | ----- | ------------------------------------------------------------ |
| 2001     | v3.23 | MySQL诞生；引入MyISAM代替原有ISAM引擎；InnoDB也可以使用；支持全文索引和复制； |
| 2003     | v4.0  | 支持新的语法；重写了复制；InnoDB成为了标配；引入了查询缓存，支持通过SSL进行连接； |
| 2005     | v4.1  | 支持新的语法；支持UTF-8字符集；支持新的二进制协议和prepared语句； |
| 2006     | v5.0  | 支持一些“企业级特性”；老的ISAM引擎的代码彻底移除；引入其他新的引擎； |
| 2008     | v5.1  | 支持分区、基于行的复制，以及 plugin API；移除了一些引擎；    |
| 2010     | v5.5  | 改善性能、扩展性、复制、分区、对微软系统的支持；InnoDB称为默认引擎；增加了PERFORMANCE_SCHEMA库； |
| 暂未发布 | v5.6  | 查询优化器大规模改进；更多的插件API；复制改进；PERFORMANCE_SCHEMA库增加更多性能指标； |

