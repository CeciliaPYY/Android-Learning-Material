## 7.5 记录日志

记录日志 API 的优点，

- 可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易；
- 可以很简单地禁止日志记录的输入，因此，将这些日志代码留在程序中的开销很小；
- 日志记录可以被定向到不同的处理器，用于在控制台中显示，用于存储在文件中等；
- 日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤实现器指定的标准丢弃那些无用的记录项；
- 日志记录可以采用不同的方式格式化，例如，纯文本或XML；
- 应用程序可以使用多个日志记录器，它们使用类似包名的这种具有层次结构的名字，例如，com.mycompany.app；
- 在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置；



### 7.5.1 基本日志

要生成简单的日志记录， 可以使用全局日志记录器(global logger) 并调用其 info 方法：

`Logger.getGlobal().info("File->Open menu item selected");`

但是， 如果在适当的地方(如 main 开始)调用

`Logger.getGlobal().setLevel(Level.OFF);`

将会取消所有的日志。



### 7.5.2 高级日志

在一个专业的应用程序中， 不要将所有的日志都记录到一个全局日志记录器中， 而是可以自定义日志记录器。

可以调用 getLogger 方法创建或获取记录器：

`private static final Logger myLogger = Logger.getLogger("com.mycompany.app");`

**Note**：未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况的发生，要像上面的例子中一样，用一个静态变量存储日志记录器的一个引用。



与包名类似， 日志记录器名也具有层次结构。 事实上， 与包名相比， 日志记录器的层次性更强。 对于包来说， 一个包的名字与其父包的名字之间没有语义关系， 但是日志记录器的父与子之间将**共享某些属性**。 例如， 如果对 com.mycompany 日志记录器设置了日志级别，它的子记录器也会**继承这个级别** 。

通常，有以下7个日志记录器级别：

- SEVERE 
-  WARNING 
-  INFO
- CONFIG 
- FINE
-  FINER 
- FINEST 

在默认情况下， 只记录前夂个级别。 也可以设置其他的级別。 例如，

`logger.setLevel(Level.FINE);`

这样， FINE 和更高级别的记录都可以记录下来。另外， 还可以使用 Level.ALL 开启所有级别的记录， 或者使用 Level.OFF 关闭所有级别的记录。

默认的日志记录将显示包含日志调用的类名和方法名， 如同堆栈所显示的那样。但是，如果虚拟机对执行过程进行了优化， 就得不到准确的调用信息。 此时，可以调用 logp 方法获得调用类和方法的确切位置，这个方法的签名为

`void logp(Level l, String className, String methodName, String Message)`

下面有一些用来跟踪执行流的方法：

`void entering(String className, String methodName)`

`void entering(String className, String methodName, Object param)`

`void entering(String className, String methodName, Object[] params)`

`void existing(String className, String methodName)`

`void existing(String className, String methodName, Object result)`

记录日志的常见用途是记录那些不可预料的异常。 可以使用下面两个方法提供日志记录中包含的异常描述内容。

`void throwing(String className, String methodName, Throwable t)`

`void log(Level l, String message, Throwable t)`

典型用法是，

`if (...) {`

`IOException exception = new IOException("...");`

`logger.throwing("com.mycompany", "read", exception);`

`throw excetion;`

`}`

还有，

`try{`

`...`

`} catch (IOException e){`

`Logger.getLogger("com.company.myapp").log(Level.WSRNING, "Reading image", e);`

`}`



### 7.5.3 修改日志管理器配置

可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下， 配置文件存在于 jre/lib/logging.properties

要想使用另一个配置文件， 就要将 java.utiUogging.config.file 特性设置为配置文件的存储位置，并用下列命令启动应用程序

`java -D java.util.logging.config.file=configFile MainClass`

**Warning**：日志管理器在 VM 启动过程中初始化， 这在 main 执行之前完成。 如果在 main中调用System.setProperty("java.util_logging.config_file"，file), 也 会 调 用 LogManager.readConfiguration() 来重新初始化曰志管理器。



要想修改默认的日志记录级别， 就需要编辑配置文件， 并修改以下命令行

`.level = INFO`

可以通过添加以下内容来指定自己的日志记录级别

`com.mycompany.app.level = FINE`

也就是说， 在日志记录器名后面添加后缀 .level。在稍后可以看到， 日志记录并不将消息发送到控制台上，这是处理器的任务。 另外， 处理器也有级别。 要想在控制台上看到 FINE 级别的消息， 就需要进行下列设置 

`Java.util.logging.ConsoleHandler.level = FINE`



### 7.5.4 本地化

日志管理器配置文件设置的默认控制台处理器的日志记录级别为

`java.util.logging.ConsoleHandler.level=INFO`

要想记录 FINE 级别的日志，就必须修改配置文件中的默认日志记录级别和处理器级别。另外，还可以绕过配置文件，安装自己的处理器。

`Logger logger = Logger.getLogger("com.company.myapp");`

`Logger.setLevel(Level.FINE);`

`Logger.setUserParentHandlers(false);`

`Handler handler = new ConsoleHandler();`

`handler.setLevel(Level.FINE);`

`logger.addHandler(handler);`

在默认情况下， 日志记录器将记录发送到自己的处理器和父处理器。 我们的日志记录器是原始日志记录器(命名为“ ”)的子类， 而原始日志记录器将会把所有等于或高于 INFO 级別的记录发送到控制台。然而，我们并不想两次看到这些记录。鉴于这个原因， 应该将 useParentHandlers 属性设置为 false。

要想将日志记录发送到其他地方， 就要添加其他的处理器。日志 AP丨为此提供了两个很有用的处理器， 一个是 **FileHandler **；另 一个是 **SocketHandler**。SocketHandler 将记录发送到特定的主机和端口。而更令人感兴趣的是 FileHandler, 它可以收集文件中的记录。

可以像下面这样直接将记录发送到默认文件的处理器：

`FileHandler handler = new FileHandler();`

`logger.addHandler(handler);`



### 7.5.6 过滤器

